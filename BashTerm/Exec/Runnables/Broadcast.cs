using BashTerm.Parsers;
using BashTerm.Sys;
using BashTerm.Utils;
using LevelGeneration;

namespace BashTerm.Exec.Runnables;

[CommandHandler("broadcast")]
public class Broadcast : IProc {
	public static string CommandName => "broadcast";
	public static string Desc => "Broadcast a message to all users! Even non-BashTerm users!";

	// TODO: maybe actually allow broadcasting to other terminals??? with the SyncID??
	public static string Manual => @"
USAGE
		broadcast [MESSAGE ...]

OPTIONS
		-m, --manifesto
				prints the broadcaster's manifesto (a total joke btw)

";

	private string _manifesto = @"If you see this, congratulate me, as I have printed something in your freaking terminal! You no longer have free will, you are now a slave to the BSH! (written by @BashTermDev, but generated by AI, Copilot specifically, so blame it on them if you don't like it)";

	public static readonly FlagSchema FSchema = CreateFlagSchema();

	private static FlagSchema CreateFlagSchema() {
		FlagSchema fs = new FlagSchema();
		fs.Add("m", "manifesto", FlagType.Boolean);
		return fs;
	}

	public PipedPayload Run(string cmd, List<string> args, CmdOpts opts, PipedPayload payload, LG_ComputerTerminal terminal) {
		if (terminal == null) throw new NullTerminalInstanceException(CommandName);
		if (opts["-m"] != null) {
			terminal.m_command.AddOutput(_manifesto);
			Bsh.SyncPrint(_manifesto);
		} else {
			var output = string.Join(" ", args.ToArray());
			terminal.m_command.AddOutput(output);
			Bsh.SyncPrint(output);
		}

		return new EmptyPayload();
	}

	public bool TryGetVarValue(LG_ComputerTerminal term, string varName, out string value) {
		value = "";
		return false;
	}

	public bool TryExpandArg(LG_ComputerTerminal term, string arg, out string expanded) {
		expanded = "";
		return false;
	}
}
