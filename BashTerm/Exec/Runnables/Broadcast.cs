using BashTerm.Parsers;
using BashTerm.Utils;
using LevelGeneration;

namespace BashTerm.Exec.Runnables;

[CommandHandler("broadcast")]
public class Broadcast : IRunnable {
	public string CommandName => "broadcast";
	public string Desc => "Broadcast a message to all users! Even non-BashTerm users!";

	// TODO: maybe actually allow broadcasting to other terminals??? with the SyncID??
	public string Manual => "Use this command to switch to GTFO native interpreter when BashTerm misbehaves, feel free to report any problems or bugs!";

	private string _manifesto = @"If you see this, congratulate me, as I have printed something in your freaking terminal! You no longer have free will, you are now a slave to the BSH! (written by @BashTermDev, but generated by AI, Copilot specifically, so blame it on them if you don't like it)";

	public FlagSchema FSchema { get; }

	public Broadcast() {
		FSchema = new FlagSchema();
		FSchema.Add("m", "manifesto", FlagType.Boolean);
	}

	public PipedPayload Run(string cmd, List<string> args, CmdOpts opts, PipedPayload payload, LG_ComputerTerminal terminal) {
		if (terminal == null) throw new NullTerminalInstanceException(CommandName);
		if (opts["-m"] != null) {
			terminal.m_command.AddOutput(_manifesto);
			Bsh.SyncPrint(_manifesto);
		} else {
			var output = string.Join(" ", args.ToArray());
			terminal.m_command.AddOutput(output);
			Bsh.SyncPrint(output);
		}

		return new EmptyPayload();
	}

	public bool TryGetVarValue(LG_ComputerTerminal term, string varName, out string value) {
		value = "";
		return false;
	}

	public bool TryExpandArg(LG_ComputerTerminal term, string arg, out string expanded) {
		expanded = "";
		return false;
	}
}
